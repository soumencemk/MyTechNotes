# __Antipatterns__

## 1. Software Design Antipatterns 
### 1.1 Abstraction inversion
### 1.2 Ambigious viewpoint
### 1.3 Database-as-IPC
### 1.4 Inner platform effect
### 1.5 Input kludge
### 1.6 Interface boat
### 1.7 Magic Push-Button
### 1.8 Race Hazzard
### 1.9 Stovepipe system

## 2. OOP Antipatterns
### 2.1 Anemic domain model
### 2.2 Call super
### 2.3 Circle-elipse problem
### 2.4 circular dependency
### 2.5 constant interface
### 2.6 God Object
### 2.7 Object cesspool
### 2.8 Object orgy
### 2.9 poltegeists
### 2.10 Sequential coupling
### 2.11 Singleton Pattern
### 2.12 Yo-Yo problem

## 3. Programming Antipatterns
### 3.1 Accidental complexity
### 3.2 Action at a distance
### 3.3 Boat anchor
### 3.4 Busy waiting
### 3.5 Caching failure
### 3.6 Cargo cult programming
### 3.7 Coding by Exception 
### 3.8 Error Hiding
### 3.9 Hard code
### 3.10 Lasagna code
### 3.11 Lava flow
### 3.12 Loop Switch sequence
### 3.13 Magic Numbers
### 3.14 Magic Strings
### 3.15 Repeating yourself
### 3.16 Shooting the messenger 
### 3.17 Shotgun surgery
### 3.18 Shotgun surgery
### 3.19 Soft code
### 3.18 Spagheti code

## 4. Methodological Antipatterns
### 4.1 Copy & Paste programming
### 4.2 Golden hammer
### 4.3 Invented here
### 4.4 Not invented here
### 4.5 Premature optimization
### 4.6 Programming by permutation
### 4.7 Reinventing the square wheel
### 4.8 Silver bullet
### 4.9 Test driven development

## 5. Cofiguration management Antipatterns
### 5.1 Dependency hell
### 5.2 DLL hell
### 5.3 Extension conflict
### 5.4 JAR Hell
